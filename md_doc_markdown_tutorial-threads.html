<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="FineFramework (FFW) is an open source framework written in C++ designed for developing applications." />
		<meta name="author" content="Matus Novak">
		<link rel="icon" href="favicon.ico">
		<title>FineFramework - Documentation</title>
		<!-- Bootstrap core CSS -->
		<link href="bootstrap.css" rel="stylesheet">
		<!-- Custom styles for this template -->
		<link href="docs.css" rel="stylesheet">
		<script type="text/javascript" src="jquery.min.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
	</head>
	<body>
		<nav class="navbar sticky-top navbar-toggleable-md navbar-light bg-faded">
		<div class="container">
		  <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
		  </button>
		  <a class="navbar-brand" href="index.html">
			<img src="logo.png" width="60" height="30" alt="">
		  </a>
		  <div class="collapse navbar-collapse" id="navbarSupportedContent">
			<ul class="navbar-nav mr-auto">
			  <li class="nav-item active"><a class="nav-link" href="index.html">Home <span class="sr-only">(current)</span></a></li>
			  <li class="nav-item"><a class="nav-link" href="modules.html">Documentation</a></li>
			  <li class="nav-item"><a class="nav-link" href="md_doc_markdown_tutorials.html">Tutorials</a></li>
			  <li class="nav-item"><a class="nav-link" href="md_doc_markdown_examples.html">Examples</a></li>
			  <li class="nav-item"><a class="nav-link" href="md_doc_markdown_faq.html">F.A.Q</a></li>
			  <li class="nav-item"><a class="nav-link" href="https://github.com/matusnovak/fineframework">GitHub</a></li>
			</ul>
			<form class="form-inline my-2 my-lg-0">
			  <a class="btn btn-outline-primary" href="md_doc_markdown_download.html" role="button">Download</a>
			</form>
		  </div>
		</div>
		</nav>
		<div class="container" id="main"><div><!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial: Threads </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial will explain how to create and launch threads using ffw::Thread and how <a class="el" href="classffw_1_1_mutex.html">ffw::Mutex</a> can be used alongside it. The threads are inside of <a href="group__math.html">math module</a> which is a header only library. All you need to do is to add <code>#include &lt;<a class="el" href="math_8h.html">ffw/math.h</a>&gt;</code> into your project. <b>This tutorial will not explain concurrency or basics of threads! You are required to know the basics.</b></p>
<p>Why another thread class? Why not std::thread? The ffw::Thread uses std::thread only if the compiler allows it. Some older GCC compilers do not have access to std::thread. If the std::thread is not available, the ffw::Thread will use POSIX pthreads instead. This also applies for <a class="el" href="classffw_1_1_mutex.html">ffw::Mutex</a>. Secondly, there are minor differences between pthreads and std::thread + std::mutex. The two classes: ffw::Thread and <a class="el" href="classffw_1_1_mutex.html">ffw::Mutex</a> make sure that no matter which thread backend is being used, the written code and the behavior will be the same.</p>
<h3>Creating thread</h3>
<p>Note that ffw::Thread uses std::function and due to many reasons you should avoid using references as function parameters for threads (pointers are welcome!). A ffw::Thread can accept both static or member functions. How to tell if a function is non-static? If the function belongs to the class and has no "static" keyword then it is not a static funtion.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Foo(<span class="keywordtype">int</span> v){</div><div class="line">    val = v;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// We create a thread to use this function</span></div><div class="line">  <span class="keywordtype">float</span> bar(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> t){</div><div class="line">    <span class="comment">// Some random algorithm</span></div><div class="line">    <span class="keywordflow">return</span> (val * p) / (float)t;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// References are not allowed.</span></div><div class="line">  <span class="comment">// Trying to call this function via ffw::Thread will</span></div><div class="line">  <span class="comment">// result in compilation error.</span></div><div class="line">  <span class="comment">// Use pointers instead!</span></div><div class="line">  <span class="keywordtype">float</span> bar_alt(<span class="keywordtype">int</span>&amp; p, <span class="keywordtype">int</span>&amp; t){</div><div class="line">    <span class="comment">// Some random algorithm</span></div><div class="line">    <span class="keywordflow">return</span> (val * p) / (float)t;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> val;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">  <span class="comment">// Create instance of Foo class</span></div><div class="line">  Foo foo(10);</div><div class="line"></div><div class="line">  <span class="comment">// Create thread instance that matches the function we are</span></div><div class="line">  <span class="comment">// going to use.</span></div><div class="line">  ffw::Thread&lt;float(int, int)&gt; thread;</div><div class="line"></div><div class="line">  <span class="comment">// Launch the thread and use Foo::bar function.</span></div><div class="line">  <span class="comment">// When calling non-static member function, you need to pass</span></div><div class="line">  <span class="comment">// the pointer to the class instance as well.</span></div><div class="line">  <span class="comment">// The function () acceps unlimited number of parameters, it will scale</span></div><div class="line">  <span class="comment">// based on the &lt;float(int, int)&gt; template parameter.</span></div><div class="line">  thread.run(&amp;Foo::bar, &amp;foo, 5, 2);</div><div class="line"></div><div class="line">  <span class="comment">// If the function was a global function, or static member function,</span></div><div class="line">  <span class="comment">// then the instance is irrelevant and you can use:</span></div><div class="line">  <span class="comment">// thread.run(&amp;Foo::bar, 5, 2);</span></div><div class="line"></div><div class="line">  <span class="comment">// Now you can do something else while the thread is running.</span></div><div class="line"></div><div class="line">  <span class="comment">// You can check if the thread is still running by calling:</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;is running? &quot;</span> &lt;&lt; thread.isRunning() &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// Note that because we are not doing any heavy work inside of</span></div><div class="line">  <span class="comment">// Foo::bar function, thread will most likely finish before you</span></div><div class="line">  <span class="comment">// manage to call thread.isRunning()</span></div><div class="line"></div><div class="line">  <span class="comment">// Always join the thread! This will release memory needed for the</span></div><div class="line">  <span class="comment">// thread. If the thread is still running, the function thread.join()</span></div><div class="line">  <span class="comment">// will not finish until the thread has finished first.</span></div><div class="line">  thread.join();</div><div class="line"></div><div class="line">  <span class="comment">// Check the result, prints: &quot;Result: 25&quot;</span></div><div class="line">  <span class="comment">// The getResult() returns float because we used &lt;float(int, int)&gt;</span></div><div class="line">  <span class="comment">// as a template parameter that mathces Foo::bar </span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; thread.getResult() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// The end</span></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>Mutex</h3>
<p>Mutex can be used to lock specific areas of the program. You are required to understand basics of mutex and concurrency. There are many great tutorials out there and there is simply no reason to create another tutorial explaining it. The following code will only explain how to use <a class="el" href="classffw_1_1_mutex.html">ffw::Mutex</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// We will store some data here,</span></div><div class="line"><span class="comment">// There is no great use for it, this is just for the purpose</span></div><div class="line"><span class="comment">// of the tutorial.</span></div><div class="line">std::vector&lt;int*&gt; data;</div><div class="line"></div><div class="line"><span class="comment">// Our mutex</span></div><div class="line"><a class="code" href="classffw_1_1_mutex.html">ffw::Mutex</a> mutex;</div><div class="line"></div><div class="line"><span class="comment">// Some global function</span></div><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">size_t</span> len, <span class="keywordtype">int</span> start){</div><div class="line">  <span class="keywordtype">int</span>* arr = <span class="keyword">new</span> <span class="keywordtype">int</span>[len];</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; len; i++){</div><div class="line">    <span class="comment">// Make square</span></div><div class="line">    arr[i] = (start + i) * (start + i);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Lock the mutex. If there is already a lock by a different thread,</span></div><div class="line">  <span class="comment">// the current thread will wait until the lock has been released.</span></div><div class="line">  mutex.<a class="code" href="classffw_1_1_mutex.html#a85d749dbb4ce8b1d4a6385e59ebb9dd0">lock</a>();</div><div class="line"></div><div class="line">  <span class="comment">// We have a lock! Push data to our array!</span></div><div class="line">  dara.push_back(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Release the lock.</span></div><div class="line">  mutex.<a class="code" href="classffw_1_1_mutex.html#a83cca312759f25f16fe17250416ee5a9">unlock</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">  ffw::Thread&lt;void(size_t, int)&gt; thread;</div><div class="line"></div><div class="line">  <span class="comment">// Launch 16 threads</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 16; i++){</div><div class="line">    thread.run(&amp;foo, 1024, i * 1024);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Wait for all threads</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 16; i++){</div><div class="line">    thread.join();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// thread.getResult() does not make sense here!</span></div><div class="line">  <span class="comment">// The function is &quot;void&quot;, you can&#39;t retun anything in void function!</span></div><div class="line"></div><div class="line">  <span class="comment">// Do something with data</span></div><div class="line">  some_kind_of_function_to_process_data(&amp;data);</div><div class="line"></div><div class="line">  <span class="comment">// Release the dynamically allocated arrays</span></div><div class="line">  <span class="keywordflow">while</span>(data.size()){ <span class="comment">// While there is anything in the vector</span></div><div class="line">    <span class="keyword">delete</span>[] data.back(); <span class="comment">// Get the element at the back (last element)</span></div><div class="line">    data.push_back(); <span class="comment">// Remove the element from back (last element)</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The end</span></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
	</div>
	<script src="tether.min.js"></script>
	<script src="bootstrap.min.js"></script>
	</body>
</html>